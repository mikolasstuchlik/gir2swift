import Foundation

private struct StreamLenght: TextOutputStream {
    var count: Int = 0

    mutating func write(_ string: String) {
        count += string.lengthOfBytes(using: .utf8)
    }
}

protocol ElementRepresentable {
    var element: StringElement { get }
}

enum StringElement: Equatable, ElementRepresentable {
    case nothing
    case line(String)
    case composition([StringElement])
    case indentationLevel([StringElement])

    var element: StringElement { self }
}

extension String: ElementRepresentable {
    var element: StringElement { .line(self) }
}

extension StringElement {
    static func normalize(_ element: StringElement) -> StringElement {
        switch element {
        case .nothing, .line:
            return element
        case let .composition(array):
            let normalized = array.map(normalize(_:)).filter { $0 != .nothing}
            if normalized.isEmpty {
                return .nothing
            } else {
                return .composition(normalized)
            }
        case let .indentationLevel(array):
            let normalized = array.map(normalize(_:)).filter { $0 != .nothing}
            if normalized.isEmpty {
                return .nothing
            } else {
                return .indentationLevel(normalized)
            }
        }
    }

    static func write<Steam: TextOutputStream>(into stream: inout Steam, element: StringElement, indentation: String, newLine: String, levels: Int) {
        switch element {
        case .nothing:
            break
        case let .line(string):
            if string.count == 0 {
                stream.write(newLine)
            } else {
                stream.write( String(repeating: indentation, count: levels) + string + newLine )
            }
        case let .composition(array):
            for item in array {
                write(into: &stream, element: item, indentation: indentation, newLine: newLine, levels: levels)
            }
        case let .indentationLevel(array):
            for item in array {
                write(into: &stream, element: item, indentation: indentation, newLine: newLine, levels: levels + 1)
            }
        }
    }

    func makeString(indentation: String = "    ", newLine: String = "\n", computeLength: Bool = true) -> String {
        let normalized = StringElement.normalize(self)
        var output: String = ""
        if computeLength {
        var length = StreamLenght()
            StringElement.write(into: &length, element: normalized, indentation: indentation, newLine: newLine, levels: 0)
            output.reserveCapacity(length.count)
        }
        StringElement.write(into: &output, element: normalized, indentation: indentation, newLine: newLine, levels: 0)
        return output
    }
}

/// Code Builder is a ResultBuilder class which provides easier-to-read way of composing string with indentation and new lines. Element of the DSL generated by this class is `String`.
@resultBuilder class CodeBuilder {

    static func buildBlock( _ segments: ElementRepresentable...) -> StringElement {
        .composition(segments.map(\.element))
    }
    
    static func buildEither(first: ElementRepresentable) -> StringElement { first.element }
    
    static func buildEither(second: ElementRepresentable) -> StringElement { second.element }
    
    static func buildOptional(_ component: ElementRepresentable?) -> StringElement { 
        if let component = component {
            return component.element
        } else {
            return .nothing
        }
    }

    static func buildIf(_ segment: ElementRepresentable?) -> StringElement { buildOptional(segment) }

    static func buildArray(_ components: [ElementRepresentable]) -> StringElement {
        .composition(components.map(\.element))
    }
}

/// Convenience class for using CodeBuilder DSL. This class was introduced to shorten calls. As for now, this class compensates for some missing DSL features like for-in loops. 
class Code {
    static func block(root: Bool = false, @CodeBuilder builder: ()->StringElement) -> StringElement {
        if root {
            return .composition([builder()])
        } else {
            return .indentationLevel([builder()])
        }
    }

    static func line(@CodeBuilder builder: ()->StringElement) -> StringElement {
        return .line(builder().makeString(indentation: "", newLine: "", computeLength: false))
    }
}
